(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{360:function(a,t,r){"use strict";r.r(t);var n=r(43),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("p",[a._v("每次nodejs做有关文件操作的时候几乎都会用到，创建文件目录啊，删除文件夹啊这样的操作。时间一久就会发现有些操作很繁琐：删除多层文件夹，创建多层文件夹。\n（注意：代码中的异步我直接用await是由于我引入了'mz/fs',mz这个包用Promise包装了下原生的操作）")]),a._v(" "),r("h4",{attrs:{id:"_1-深（多）层删除文件夹"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-深（多）层删除文件夹"}},[a._v("#")]),a._v(" 1 深（多）层删除文件夹")]),a._v(" "),r("p",[a._v("node提供了删除文件夹的操作：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("fs.rmdir()     // 异步的\nfs.rmdirSync()  //同步的\n")])])]),r("p",[a._v("但该操作仅仅能删除空文件夹。\n那么假如我们有如下这样的一个文件夹\n"),r("img",{attrs:{src:"/img/js/upload_images/6191737-fcc31c22b4c7845b.png",alt:"目录"}})]),a._v(" "),r("p",[a._v("我们要删掉1这个目录那么得先干掉里面的文件和文件夹，里面的文件夹要干掉就需要再干掉里面的文件和文件夹。好了道理貌似都懂关键是代码怎么写。")]),a._v(" "),r("p",[a._v("下面是代码：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('let rmDirs = (function () {\n        async function iterator(url, dirs) {\n            var stat = await fs.stat(url);\n            if (stat.isDirectory()) {\n                dirs.unshift(url); //收集目录\n                await inner(url, dirs);\n            } else if (stat.isFile()) {\n                await fs.unlink(url); //直接删除文件\n            }\n        }\n\n        async function inner(path, dirs) {\n            var arr = await fs.readdir(path);\n            await Promise.all(arr.map(v => iterator(path + "/" + v, dirs)));\n        }\n\n        return async function (dir) {\n            var dirs = [];\n            try {\n                await iterator(dir, dirs);\n                //继发：先删最里层然后依次删外层\n                 for (let v of dirs) {\n                    await fs.rmdir(v);\n                }\n                //并发：所有文件夹一起可能会报错\n                /*  await Promise.all(dirs.map(v => fs.rmdir(v)));*/\n            } catch (e) {\n                throw e;\n            }\n        }\n    })();\n')])])]),r("h4",{attrs:{id:"_2-深（多）层创建文件夹"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-深（多）层创建文件夹"}},[a._v("#")]),a._v(" 2 深（多）层创建文件夹")]),a._v(" "),r("p",[a._v("nodejs提供了文件夹创建的的操作:")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("fs.mkdir() //异步\nfs.mkdirSync() //同步\n")])])]),r("p",[a._v("但该操作只能在已有的文件夹下创建文件夹")]),a._v(" "),r("p",[a._v("假如c:/a 下什么都没有，我们想建 c:/a/b/c/d/e/f\n如果直接将这个路径给mkdir是肯定不行的。\n那么坑定是要获取这个路径的上级目录如果存在侧返回true，后面判断是true的时候就创建，如果不存在就继续找上级目录存在的时候返回true，不存在继续找上级目录。\n下面是代码：")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v(" /* 深层创建文件目录 */\n    async mkDirs(dirname) {\n        if (await fs.exists(dirname)) {\n            return true\n        } else {\n            if (await this.mkDirs(path.dirname(dirname))) {\n                await fs.mkdir(dirname)\n                return true\n            }\n        }\n    };\n")])])]),r("p",[a._v("就是这么点。")]),a._v(" "),r("h4",{attrs:{id:"_3总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3总结"}},[a._v("#")]),a._v(" 3总结")]),a._v(" "),r("p",[a._v("代码随简但是凡事要多思考，比如把诸如此类的操作的方法都放在一个工具类中，再做成单例模式。")])])}),[],!1,null,null,null);t.default=s.exports}}]);